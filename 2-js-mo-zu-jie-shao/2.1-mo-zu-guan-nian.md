# 2.1 模組觀念

## 範例 1：建立模組及匯入

請在 **`practice/modules`** 資料夾裡，建立 **`say_hi.js`** 檔案。

然後在 **`practice`** 資料夾裡，建立 **`module_test1.html`** 檔案。



`say_hi.js` 檔案內容如下：

```javascript
export function hi(user) {
  return `Hi, ${user}!`;
}
```

`module_test1.html` 檔案內容如下：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      import { hi } from './modules/say_hi.js';

      console.log( hi("John") );
    </script>
  </body>
</html>

```

然後使用本機端網域的方式來開啟，例： `http://127.0.0.1:3000/practice/module_test1.html` 。



藉由以上的例子，我們得知以下的結論：

* **`say_hi.js`** 是一個模組檔，並使用 **`export`** 關鍵字來匯出一個 hi() 函式。
* 若要匯入模組檔，需在 **`script`** 標籤上，加 **`type="module"`** 才能使用 **`import`** 關鍵字來匯入模組檔。
* 使用 **`import`** 關鍵字來匯入模組檔時，需有對應的**`相同名稱`**(此例是 **`hi`** )來承接匯入的東西(此例是 **`hi()`** 函式)。







## 範例 2：模組的程式只會被執行一次且是共用

即使多次載入，仍只會執行一次。

建立 `modules/alert.js` 檔，內容如下：

```javascript
alert("測試");
```

建立 `modules/1.js` 和 `modules/2.js`，內容如下：

```javascript
import "./alert.js";
```

建立 `module_test3.html`，內容如下：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="module">
      import "./modules/1.js";
      import "./modules/2.js";
    </script>
  </body>
</html>
```

使用本機端網域方式，瀏覽 `module_test3.html`，得知 `1.js` 和 `2.js` 雖然都載入了 `alert.js`，但 `alert.js` 檔裡面的程式，只會被執行一次。



然後再測另一個情況，將 `alert.js` 改成如下(即匯出變數)：

```javascript
export let admin = {
  name: "John"
};
```

`1.js` 改成如下：

```javascript
import { admin } from './alert.js';
admin.name = "Pete";
```

`2.js` 改成如下：

```javascript
import { admin } from './alert.js';
alert(admin.name); // Pete
```

然後一樣使用本機端網域方式，瀏覽 `module_test3.html`，得知 `1.js` 修改了屬性，會影響到 2.js 裡的內容。也就是**相同模組的程式碼，都是共用的**。



## 範例 3：import.meta

認識 **`import.meta`** 物件：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      console.log(import.meta);
    </script>
  </body>
</html>
```

結果如下圖：

![import.meta 物件](../.gitbook/assets/import\_meta.png)



## 範例 4：其它特性

一、關於 **`this`**：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script>
      console.log(this); // 會印出 window 物件
    </script>
  </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      console.log(this); // undefined
    </script>
  </body>
</html>
```



二、本身就具有 **`defer`** 的特性

也就是會在 HTML 所有節點在畫面上渲染出來之後，才會執行模組的程式，如下示意：

```html
<script type="module">
  // code
</script>

<script type="module" src="/path"></script>
```

相當於 DOMContentLoaded 事件。



三、可以加上 **`async`** 屬性，來表達非同步

以下程式，加上 **`async`** 屬性，會變成馬上去執行，也就是變成不具有 **`defer`** 的特性：

```html
<script async type="module">
  // code
</script>
```



四、重覆載入的話，只會執行一次

以下程式，**`my.js`** 檔案只會被執行一次，當然本來就不應該造成有以下寫兩次的情況：

```html
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```



五、跨網域載入模組的程式

需要在 Server 端，允許下載，也就是 **`Access-Control-Allow-Origin`**。

```html
<script type="module" src="http://another-site.com/their.js"></script>
```



六、相容性，**`nomodule`** 屬性

以下程式，若想讓不支援 **`module`** 功能的瀏覽器，執行其它程式的話，可以加上 **`nomodule`** 屬性：

```html
<script type="module">
  alert("有支援 module 功能的瀏覽器，才會執行這裡。");
</script>

<script nomodule>
  alert("當代瀏覽器(有支援 module 功能)，不會執行這裡(因為加上了 nomodule 屬性)。")
  alert("舊版瀏覽器(不支援 module 功能)，會執行這裡的程式(因為加上了 nomodule 屬性)。");
</script>
```



