# 2.1 模組觀念

## 範例 1：建立模組及匯入

請在 `modules` 資料夾裡，建立 **`say_hi.js`** 檔案。

然後在 **`practice`** 資料夾裡，建立 **`module_test1.html`** 檔案。



`say_hi.js` 檔案內容如下：

```javascript
export function hi(user) {
  return `Hello, ${user}!`;
}
```

`module_test1.html` 檔案內容如下：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      import { hi } from './modules/say_hi.js';

      console.log( hi("John") );
    </script>
  </body>
</html>

```

然後使用本機端網域的方式來開啟，例： `http://127.0.0.1:3000/practice/module_test1.html` 。



藉由以上的例子，我們得知以下的結論：

* **`say_hi.js`** 是一個模組檔，並使用 **`export`** 關鍵字來匯出一個 hi() 函式。
* 若要匯入模組檔，需在 **`script`** 標籤上，加 **`type="module"`** 才能使用 **`import`** 關鍵字來匯入模組檔。
* 使用 **`import`** 關鍵字來匯入模組檔時，需有對應的**`相同名稱`**(此例是 **`hi`** )來承接匯入的東西(此例是 **`hi()`** 函式)。



## 範例 2：模組可視範圍

當在 script 標籤上使用 `type="module"` 時，有以下兩個特性：

* 直接具有 **`"use strict";`** 特性，也就是嚴格模式。
* 模組內的變數可視範圍，只有在模組內。



建立 **`practice/modules/user.js`**，內容如下：

```javascript
let user = "John";
```

建立 **`practice/modules/hello.js`**，內容如下：

```javascript
alert(user);
```

建立 **`practice/module_test2.html`**，內容如下：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="module" src="./modules/user.js"></script>
    <script type="module" src="./modules/hello.js"></script>
  </body>
</html>
```

以上程是會報錯的，因為在 `hello.js` 檔案中，`user` 變數未定義。(反之，如果將 **`type="module"`** 移除，就會正常)。



相同的例子，以上三個檔案分別改成如下：

**`user.js`**：

```javascript
export let user = "John"; // 使用 export 關鍵字，將 user 變數匯出
```

**`hello.js`**：

```javascript
import { user } from './user.js'; // 載入模組，然後承接 user 變數

alert(user);
```

**`module_test2.html`**：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="module" src="./modules/hello.js"></script>
  </body>
</html>
```

此程式就會正常，在 `hello.js` 當中，載入了另一個模組檔( `user.js` )，`user` 變數有正確的取得資料。



透過這個例子，我們也瞭解到除了上面提到的兩個 特性 之外，還有：

* 變數，也可以使用 **`export`** 關鍵字來匯出。
* 在 **`script`** 標籤上，使用 **`type="module"`** 時，也可以使用 **`src="路徑"`** 來載入模組。



## 範例 3：模組的程式只會被執行一次且是共用

即使多次載入，仍只會執行一次。

建立 `modules/alert.js` 檔，內容如下：

```javascript
alert("測試");
```

建立 `modules/1.js` 和 `modules/2.js`，內容如下：

```javascript
import "./alert.js";
```

建立 `module_test3.html`，內容如下：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="module">
      import "./modules/1.js";
      import "./modules/2.js";
    </script>
  </body>
</html>
```

使用本機端網域方式，瀏覽 `module_test3.html`，得知 `1.js` 和 `2.js` 雖然都載入了 `alert.js`，但 `alert.js` 檔裡面的程式，只會被執行一次。



然後再測另一個情況，將 `alert.js` 改成如下(即匯出變數)：

```javascript
export let admin = {
  name: "John"
};
```

`1.js` 改成如下：

```javascript
import { admin } from './alert.js';
admin.name = "Pete";
```

`2.js` 改成如下：

```javascript
import { admin } from './alert.js';
alert(admin.name); // Pete
```

然後一樣使用本機端網域方式，瀏覽 `module_test3.html`，得知 `1.js` 修改了屬性，會影響到 2.js 裡的內容。也就是**相同模組的程式碼，都是共用的**。



## 範例 4：import.meta

認識 **`import.meta`** 物件：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      console.log(import.meta);
    </script>
  </body>
</html>
```

結果如下圖：

![import.meta 物件](../.gitbook/assets/import\_meta.png)



## 範例 5：其它特性

一、關於 **`this`**：

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script>
      console.log(this); // 會印出 window 物件
    </script>
  </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="module">
      console.log(this); // undefined
    </script>
  </body>
</html>
```



二、本身就具有 **`defer`** 的特性

也就是會在 HTML 所有節點在畫面上渲染出來之後，才會執行模組的程式，如下示意：

```html
<script type="module">
  // code
</script>

<script type="module" src="/path"></script>
```

相當於 DOMContentLoaded 事件。



三、可以加上 **`async`** 屬性，來表達非同步

以下程式，加上 **`async`** 屬性，會變成馬上去執行，也就是變成不具有 **`defer`** 的特性：

```html
<script async type="module">
  // code
</script>
```



四、重覆載入的話，只會執行一次

以下程式，**`my.js`** 檔案只會被執行一次，當然本來就不應該造成有以下寫兩次的情況：

```html
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```



五、跨網域載入模組的程式

需要在 Server 端，允許下載，也就是 **`Access-Control-Allow-Origin`**。

```html
<script type="module" src="http://another-site.com/their.js"></script>
```



六、相容性，**`nomodule`** 屬性

以下程式，若想讓不支援 **`module`** 功能的瀏覽器，執行其它程式的話，可以加上 **`nomodule`** 屬性：

```html
<script type="module">
  alert("有支援 module 功能的瀏覽器，才會執行這裡。");
</script>

<script nomodule>
  alert("當代瀏覽器(有支援 module 功能)，不會執行這裡(因為加上了 nomodule 屬性)。")
  alert("舊版瀏覽器(不支援 module 功能)，會執行這裡的程式(因為加上了 nomodule 屬性)。");
</script>
```



