# 4.6 Computed Properties 和 Watcher

## Computed Properties



### 範例 1：簡化 template 上的邏輯

```javascript
const RootComponent = {
  data(){
    return {
      author: {
        name: "作者名稱",
        books: ["書名一", "書名二", "書名三"]
      }
    };
  },
  computed: {
    have_books(){
      return (this.author.books.length > 0 ? `有 ${this.author.books.length} 本書` : "沒有書");
    }
  }
};
```

在 html 上，對應上方的 computed，可以透過以下寫法取得資料：

```html
<p>{{ have_books }}</p>
```

如果不透過 computed，那也可以寫這樣，但較不易讀：

```html
<p>{{ author.books.length > 0 ? `有 ${this.author.books.length} 本書` : "沒有書" }}</p>
```



範例連結：[https://codepen.io/carlos411/pen/NWaoEyK](https://codepen.io/carlos411/pen/NWaoEyK)

{% embed url="https://codepen.io/carlos411/pen/NWaoEyK" %}



### 範例 2：若 data 資料有改變，那麼 Computed Properties 的資料會跟著改變



範例連結：[https://codepen.io/carlos411/pen/oNGmQmM](https://codepen.io/carlos411/pen/oNGmQmM)

{% embed url="https://codepen.io/carlos411/pen/oNGmQmM" %}



### 範例 3：跟 methods 的差異，在於 Cache 的機制

只要 Computed Properties 裡的函式執行完之後，資料就會 Cache 。**所以效能較好**。

例如下方的 `reverse_book_string1()` 函式一旦觸發，就會產生一個屬性叫做 `reverse_book_string1`，對應的資料會是函式的回傳結果，然後就不會再變了，除非 `data` 裡的資料有更動：

```javascript
computed: {
  reverse_book_string1(){
    console.log("這個會執行到嗎？");
    return this.author.books.reverse().join();
  }
}
```



範例連結：[https://codepen.io/carlos411/pen/poWGQmN](https://codepen.io/carlos411/pen/poWGQmN)

{% embed url="https://codepen.io/carlos411/pen/poWGQmN" %}



{% hint style="info" %}
Computed Properties 適合用在 **想將資料 Cache 下來的情況**；

以及 **是 data 資料當中的變形**。
{% endhint %}



### 範例 4：Computed Properties 當中的 get() 與 set()

基本上，Computed Properties 資料是唯讀的，無法直接修改它。

若要修改，寫法形式如下，留意 full\_name 的 `get()` 與 `set()`以及修改的方法(第 33 行)：

```javascript
const MyAppSetting = {
  data(){
    return {
      first_name: "Carlos",
      last_name: "Chang"
    };
  },
  
  // 對應寫法二
  computed: {
    
    // 此寫法可以，但無法直接針對 full_name 改變資料
    /*
    full_name(){
      return `${this.first_name} ${this.last_name}`;
    }
    */
    
    // 若要直接改變 full_name，則需使用 get() 與 set()，
    full_name: {
      get(){
        return `${this.first_name} ${this.last_name}`;
      },
      set(new_name){
        var my_new_name = new_name.split(' '); // ["Andy", "Lau"]
        this.first_name = my_new_name[0];
        this.last_name = my_new_name[1];
      }
    }
  },
  methods: {
    change_name(){
      this.full_name = "Andy Lau";
    }
  }
};
```



範例連結：[https://codepen.io/carlos411/pen/PoJVLMM](https://codepen.io/carlos411/pen/PoJVLMM)

{% embed url="https://codepen.io/carlos411/pen/PoJVLMM" %}



## Watchers(監控資料)

在 **`watch`** 屬性當中，監控 data 當中的某個資料，如下例的 question，留意註解的地方：

```javascript
const MyAppSetting = {
  data() {
    return {
      question: "Q",
      answer: "A"
    }
  },
  watch: {
    // 監控 question 資料：也就是當 question 資料有改變時，這個函式就會觸發
    question(newQuestion, oldQuestion) {
      console.log(newQuestion); // 這是新的資料
      console.log(oldQuestion); // 這是原來的資料
      if (newQuestion.indexOf('?') > -1) {
        this.getAnswer()
      }
    }
  }
};
```



範例連結：[https://codepen.io/carlos411/pen/PoJVLMM](https://codepen.io/carlos411/pen/PoJVLMM)

{% embed url="https://codepen.io/carlos411/pen/PoJVLMM" %}



